#PlotPy for Falling Sand

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import trackpy as tp

import av
import pims
import math

import pandas as pd
from pandas import DataFrame, Series

frames_per_second = 1000
"""The frames per second of the camera being used"""

class particle:
	"""This is a class representing a single particle found by Trackpy"""

	used_index = []
	"""used_index (list of ints): The static list of DataFrame indices generated by Trackpy that pass filtering."""

	def __init__(self, ID):
		"""
		The constructor of the particle class.

			Parameters: 
				ID (int): The particle ID assigned by Trackpy when linking trajectories from features.
		"""
		self.index = []
		"""index (list of ints): The list of DataFrame indicies generated by Trackpy that the particle uses"""
		self.ID = ID
		"""ID (int): The particle ID assigned by Trackpy when linking trajectories from features."""
		self.diameter = 0
		"""diameter (double): The averaged size of the particle in the frames it appears in, in pixels."""
		self.ecc = 0
		"""ecc (double): The averaged eccentricity of the particle in the frames it appears in."""
		self.polyline = None
		"""polyline (NumPy polyline): The quadratic polynomial line of best fit for the particle's position."""

		self.pos_derivative = ([], [], [], [])		
		"""pos_derivative (tuple of lists): The tuple of the 0th, 1st, 2nd and 3rd derivatives of position, which is encoded as a list of tuples in the form
		of (x (double), y (double), error (tuple), frame(double)) for derivatives 1 - 3, with error being a tuple (x error (double), y error (double))."""
		self.irregular = []
		"""irregular (list of ints): The list of indicies where an irregular motion occurs."""
		self.average = []
		"""average (list of tuple): The list of a particle's average derivatives of position using the tuple (x (double), y (double))."""

	def add_index(self, coord, diameter, ecc, index):
		"""
		The method that adds the information in an index of TrackPy's trajectory DataFrame to it's associated particle.
			
			Parameters:
				coord (single tuple of objects): The positional information of the particle using tuple (x (double), y (double), error (double), frame(double)).
				diameter (double): The diameter of the particle in pixels.
				ecc (double): The eccentricty of the particle.
				index (int): the index of the DataFrame being evaluated.
		"""
		self.diameter = (self.diameter * len(self.pos_derivative[0]) + diameter) / (len(self.pos_derivative[0]) + 1)
		self.ecc = (self.ecc * len(self.pos_derivative[0]) + ecc) / (len(self.pos_derivative[0]) + 1)
		self.index.append(index)
		self.pos_derivative[0].append(coord)

		if index not in self.used_index:
			self.used_index.append(index)

	def calc_polyline(self):
		"""
			The method that calculates a quadratic line of best fit for the particle's position coordinates.
		"""
		x = []
		y = []

		for i in range(0, len(self.pos_derivative[0])):
			x.append(self.pos_derivative[0][i][0])
			y.append(self.pos_derivative[0][i][1])

		self.polyline = np.poly1d(np.polyfit(np.array(x), np.array(y), 2))

	def calc_vel(self, angle):
		"""
			The method that calculates the particle's velocity from its position.

			Parameters:
				angle (double): The maximum angle in radians a particle can move between positions before it's considered an irregular motion.
		"""
		self.average.append((0, 0))

		for i in range (0, len(self.pos_derivative[0]) - 1):
			dt = (self.pos_derivative[0][i + 1][3] - self.pos_derivative[0][i][3]) / frames_per_second
			t = (self.pos_derivative[0][i + 1][3] + self.pos_derivative[0][i][3]) / 2

			err = ((self.pos_derivative[0][i][2] * self.pos_derivative[0][i + 1][0] - self.pos_derivative[0][i + 1][2] * self.pos_derivative[0][i][0]) / dt, 
				(self.pos_derivative[0][i][2] * self.pos_derivative[0][i + 1][1] - self.pos_derivative[0][i + 1][2] * self.pos_derivative[0][i][1]) / dt)

			self.pos_derivative[1].append(((self.pos_derivative[0][i + 1][0] - self.pos_derivative[0][i][0]) / dt, 
				(self.pos_derivative[0][i + 1][1] - self.pos_derivative[0][i][1]) / dt, err, t))
			self.average[-1]  = (self.average[-1][0] + self.pos_derivative[1][-1][0], self.average[-1][1] + self.pos_derivative[1][-1][1])

			if len(self.pos_derivative[1]) > 1 and get_cos(self.pos_derivative[1][-1], self.pos_derivative[1][-2]) < math.cos(angle):
				self.irregular.append(self.index[i])

		self.average[-1] = (self.average[-1][0] / len(self.pos_derivative[1]), self.average[-1][1] / len(self.pos_derivative[1]))

	def calc_accel(self):
		"""The method that calculates a particle's acceleration from its velocity."""
		self.average.append((0, 0))

		for i in range (0, len(self.pos_derivative[1]) - 1):
			dt = (self.pos_derivative[1][i + 1][3] - self.pos_derivative[1][i][3]) / frames_per_second
			t = (self.pos_derivative[1][i + 1][3] + self.pos_derivative[1][i][3]) / 2

			err = ((self.pos_derivative[1][i][2][0] * self.pos_derivative[1][i + 1][0] - self.pos_derivative[1][i + 1][2][0] * self.pos_derivative[1][i][0]) / dt, 
				(self.pos_derivative[1][i][2][1] * self.pos_derivative[1][i + 1][1] - self.pos_derivative[1][i + 1][2][1] * self.pos_derivative[1][i][1]) / dt)

			self.pos_derivative[2].append(((self.pos_derivative[1][i + 1][0] - self.pos_derivative[1][i][0]) / dt, 
				(self.pos_derivative[1][i + 1][1] - self.pos_derivative[1][i][1]) / dt, err, t))
			self.average[-1]  = ((self.average[-1][0] * len(self.pos_derivative[2]) + self.pos_derivative[2][-1][0]) / (len(self.pos_derivative[2]) + 1), 
								(self.average[-1][1] * len(self.pos_derivative[2]) + self.pos_derivative[2][-1][1]) / (len(self.pos_derivative[2]) + 1))

	def calc_jerk(self):
		"""The method that calculates a particle's jerk from its acceration."""
		self.average.append((0, 0))

		for i in range (0, len(self.pos_derivative[2]) - 1):
			dt = (self.pos_derivative[2][i + 1][3] - self.pos_derivative[2][i][3]) / frames_per_second
			t = (self.pos_derivative[2][i + 1][3] + self.pos_derivative[2][i][3]) / 2

			err = ((self.pos_derivative[2][i][2][0] * self.pos_derivative[2][i + 1][0] - self.pos_derivative[2][i + 1][2][0] * self.pos_derivative[2][i][0]) / dt, 
				(self.pos_derivative[2][i][2][1] * self.pos_derivative[2][i + 1][1] - self.pos_derivative[2][i + 1][2][1] * self.pos_derivative[2][i][1]) / dt)

			self.pos_derivative[3].append(((self.pos_derivative[2][i + 1][0] - self.pos_derivative[2][i][0]) / dt, 
				(self.pos_derivative[2][i + 1][1] - self.pos_derivative[2][i][1]) / dt, err, t))
			self.average[-1]  = (self.average[-1][0] + self.pos_derivative[3][-1][0], self.average[-1][1] + self.pos_derivative[3][-1][1])

	def analyze(self, angle):
		"""
			The method that calculates all derivatives of position and the polyline of a particle.

			Parameter:
				angle (double): The maximum angle in radians a particle can move between positions before it's considered an irregular motion.
		"""
		self.calc_polyline()
		self.calc_vel(angle)
		self.calc_accel()
		self.calc_jerk()

def get_cos(v1, v2):
	#Helper function to get the angle of two vectors.

	numerator = v1[0] * v2[0] + v1[1] * v2[1]
	denominator = math.sqrt(math.pow(v1[0], 2) + math.pow(v1[1], 2)) * math.sqrt(math.pow(v2[0], 2) + math.pow(v2[1], 2))

	return numerator / denominator

@pims.pipeline
def to_grey(frame):
	"""
		The function that converts a NumpyArray to greyscale.

		Parameters:
			frame (NumpyArray): The NumpyArray representing a video frame.

		Returns:
			frame (NumpyArray): The NumpyArray taken in and converted to greyscale.
	"""
	red = frame[:, :, 0]
	blue = frame[:, :, 1]
	green = frame[:, :, 2]

	return red * 0.2125 + green * 0.7154 + blue * 0.0721

def evaluate_features(video_name, particle_size, particle_minmass, start_frame, length, noise):
	"""
		The function that converts a video to a greyscale NumpyArray and then runs Trackpy's feature detection algorithm on the arrays.

		Parameters:
			video_name (String): The name of the video to be evaluated stored in the Recordings folder.
			particle_size (int): The odd-number size of the feature to be detected by Trackpy.
			particle_minmass (double): The minimum feature brightness to filter using Trackpy's filtering functions.
			start_frame (int): The frame in the video from which to begin evaluation.
			length (int): The number of frames to evaluate.

		Returns:
			frame (DataFrame): The DataFrame of the features found in the video.
	"""
	frames = to_grey(pims.PyAVReaderTimed(video_name))
	f = tp.batch(frames[start_frame: start_frame + length], particle_size, minmass = particle_minmass, noise_size = noise)

	return f

def evaluate_trajectories(data_frame, search_size, lb_search_size, step, particle_memory):
	"""
		The function that links features previously discovered by Trackpy and creates a trajectory.

		Parameters:
			
	"""
	pred = tp.predict.NearestVelocityPredict()
	#Gets the DataFrame of the trajectories
				
	t = pred.link_df(data_frame, search_size, adaptive_stop = lb_search_size, adaptive_step = step, memory = particle_memory)

	return t

#Returns a Dictionary containing a list of particle motion from a trajectory DataFrame
def extract_particles(traj):
	#return dictionary
	particles = dict()

	for i in range (0, traj.shape[0]):
		#ID of Particle
		ID = traj.at[i, "particle"]

		if ID not in particles:
			particles[ID] = particle(ID)

		particles[ID].add_index((traj.at[i, "x"], traj.at[i, "y"], traj.at[i, "ep"] / 2, traj.at[i, "frame"]), traj.at[i, "size"] * 2, traj.at[i, "ecc"], i)

	return particles

#Splits a single particle and returns another particle
def split(data_frame, p, filter_stub, angle):
		return_particles = []
		for x in range(0, len(p.irregular) + 1):
			return_particles.append(particle(data_frame.max()[9] + 1 + x))

		return_index = 0
		for x in p.index:
			#if you've reached the irregularity index
			if x in p.irregular:
				return_index += 1

			return_particles[return_index].add_index((data_frame.at[x, "x"], data_frame.at[x, "y"], data_frame.at[x, "ep"] / 2, data_frame.at[x, "frame"]), 
													data_frame.at[x, "size"] * 2, data_frame.at[x, "ecc"], x)

		for rp in return_particles.copy():
			if len(rp.pos_derivative[0]) < filter_stub:
				for x in range(0, len(return_particles)):
					if return_particles[x].ID == rp.ID:
						return_particles.pop(x)
						break;
				for x in rp.index:
					particle.used_index.remove(x)

		for rp in return_particles:
			rp.analyze(angle)
			for x in rp.index:
				data_frame.at[x, "particle"] = rp.ID

		data_frame = data_frame.loc[particle.used_index]

		return return_particles

#Remerge previously unaffiliated trajectories
def merge(data_frame, particles, error_tolerance, angle):
	evaluated_particles = []

	for p1 in particles.copy():
		evaluated_particles.append(p1.ID)
		poly = p1.polyline
		lse = 0

		for p2 in particles.copy():
			if p2.ID not in evaluated_particles:
				for i in range(0, len(p2.pos_derivative[0])):
					lse += math.pow(poly(p2.pos_derivative[0][i][0]) - p2.pos_derivative[0][i][1], 2)

				lse = math.sqrt(lse / len(p2.pos_derivative[0]))

				if lse < error_tolerance:
					evaluated_particles.append(p2.ID)
					for i in range(0, len(particles)):
						if particles[i].ID == p1.ID:
							for x in p2.index:
								data_frame.at[x, "particle"] = particles[i].ID
								particles[i].add_index((data_frame.at[x, "x"], data_frame.at[x, "y"], data_frame.at[x, "ep"], data_frame.at[x, "frame"]), 
													data_frame.at[x, "size"] * 2, data_frame.at[x, "ecc"], x)
							particles[i].analyze(angle)
						if particles[i].ID == p2.ID:
							particles.pop(i)

	return particles

def unfilter_jumps(data_frame, particles, filter_stub, error_tolerance, angle):
	#For all the particles
	for p in particles.copy().values():
		if not len(p.irregular) == 0:
			new_particles = merge(data_frame, split(data_frame, p, filter_stub, angle), error_tolerance, angle)
			particles.pop(p.ID)
			for split_particles in new_particles:
				particles[split_particles.ID] = split_particles

	return data_frame.loc[particle.used_index]

#filter stub that doesn't delete the index 
def fixed_filter_stubs(data_frame, i):
	t = tp.filter_stubs(data_frame, i)
	t.index = range(0, len(t))

	return t

def postfiltering(data_frame, particles, stillness, tolerance, angle, error_tolerance, filter_stub):
	#Post Filtering
	for p in particles.copy().values():
		p.analyze(angle)

		#If the particle is effectipos_derivative[1]y stationary or the particles experience collision
		if (abs(p.average[0][1]) < stillness and abs(p.average[0][1] < stillness)) or len(p.irregular) > tolerance:
			particles.pop(p.ID)

			#remove from 
			for i in p.index:
				particle.used_index.remove(i)

	unfilter_jumps(data_frame, particles, filter_stub, error_tolerance, angle)

	data_frame = data_frame.loc[particle.used_index]

	return data_frame

def export(data_frame, particles = None):
	if particles == None:
		raw_data = data_frame.copy()
		raw_data.to_excel("output.xlsx", sheet_name = "raw_data")

	else:
		#data to turn into excel sheets
		raw_data = data_frame.copy()
		velocity_data = dict({"x_vel": [], "y_vel": [], "x_err": [], "y_err": [], "frame": [], "particle": []})
		acceleration_data = dict({"x_accel": [], "y_accel": [], "x_err": [], "y_err": [], "frame": [], "particle": []})
		jerk_data = dict({"x_jerk": [], "y_jerk": [], "x_err": [], "y_err": [], "frame": [], "particle": []})

		for p in particles.values():
			for i in range (0, len(p.pos_derivative[1])):
				velocity_data["x_vel"].append(p.pos_derivative[1][i][0])
				velocity_data["y_vel"].append(p.pos_derivative[1][i][1])
				velocity_data["x_err"].append(p.pos_derivative[1][i][2][0])
				velocity_data["y_err"].append(p.pos_derivative[1][i][2][1])
				velocity_data["frame"].append(p.pos_derivative[1][i][3])
				velocity_data["particle"].append(p.ID)

				if i < len(p.pos_derivative[2]):
					acceleration_data["x_accel"].append(p.pos_derivative[2][i][0])
					acceleration_data["y_accel"].append(p.pos_derivative[2][i][1])
					acceleration_data["x_err"].append(p.pos_derivative[2][i][2][0])
					acceleration_data["y_err"].append(p.pos_derivative[2][i][2][1])
					acceleration_data["frame"].append(p.pos_derivative[2][i][3])
					acceleration_data["particle"].append(p.ID)

				if i < len(p.pos_derivative[3]):
					jerk_data["x_jerk"].append(p.pos_derivative[3][i][0])
					jerk_data["y_jerk"].append(p.pos_derivative[3][i][1])
					jerk_data["x_err"].append(p.pos_derivative[3][i][2][0])
					jerk_data["y_err"].append(p.pos_derivative[3][i][2][1])
					jerk_data["frame"].append(p.pos_derivative[3][i][3])
					jerk_data["particle"].append(p.ID)

		velocity_data = pd.DataFrame.from_dict(velocity_data)
		acceleration_data = pd.DataFrame.from_dict(acceleration_data)
		jerk_data = pd.DataFrame.from_dict(jerk_data)

		with pd.ExcelWriter("output.xlsx") as writer:
			raw_data.to_excel(writer, sheet_name = "raw data")
			velocity_data.to_excel(writer, sheet_name = "velocity data")
			acceleration_data.to_excel(writer, sheet_name = "acceleration data")
			jerk_data.to_excel(writer, sheet_name = "jerk data")